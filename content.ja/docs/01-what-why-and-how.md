---
title: 何を、なぜ、どのように
type: docs
weight: 2
---


# WebRTCとは？

WebRTCとは、Web Real-Time Communicationの略で、APIであると同時にプロトコルでもあります。WebRTCプロトコルは、2つのWebRTCエージェントが双方向の安全なリアルタイム通信をネゴシエートするための一連のルールです。WebRTC APIは、開発者がWebRTCプロトコルを使用するためのものです。WebRTC APIは、JavaScriptのみで規定されています。

似たような関係として、HTTPとfetch APIがあります。プロトコルのWebRTCがHTTPで、APIのWebRTCがfetch APIとなります。

WebRTCプロトコルは、JavaScript以外のAPI/言語でも利用可能です。また、WebRTC用のサーバーやドメイン固有のツールもあります。これらの実装はすべて WebRTC プロトコルを使用しており、相互にやりとりすることができます。

WebRTCプロトコルは、IETFの[rtcweb](https://datatracker.ietf.org/wg/rtcweb/documents/)というワーキンググループで管理されています。WebRTC APIは、W3Cの[webrtc-pc](https://w3c.github.io/webrtc-pc/)で文書化されています。

## なぜWebRTCを学ぶ必要があるのか？

WebRTC を使うことで得られるものは以下の通りです。このリストはすべてを網羅しているわけではありませんが、あなたが旅をしている間に感謝することもあるでしょう。これらの用語のいくつかをまだ知らなくても、この本が教えてくれますのでご安心ください。

* オープンスタンダード
* 複数の実装
* ブラウザで利用可能
* 必須の暗号化
* NATトラバーサル
* 既存技術の再利用
* 輻輳（ふくそう）制御
* サブセカンドレイテンシー

## WebRTCプロトコルは他の技術の集合体である

これは、本1冊分の説明が必要なテーマです。しかし、ここでは4つのステップに分けて説明します。

* シグナリング
* 接続
* セキュリティの確保
* 通信

この4つのステップは順番に行われます。前のステップが100％成功しなければ、次のステップは始まりません。

WebRTCの奇妙な点は、各ステップが実際には他の多くのプロトコルで構成されていることです。WebRTCを作るためには、多くの既存技術をつなぎ合わせます。その意味では、WebRTCは2000年代初頭から存在する、よく理解された技術を組み合わせて構成したものと言えます。

これらのステップはそれぞれ専用の章を設けていますが、まずは大まかに理解しておくと便利です。これらの手順はお互いに依存しているため、それぞれの手順の目的をさらに説明する際に役立ちます。

### シグナリング: WebRTCでピアがお互いを見つける方法

WebRTCエージェントが起動したとき、誰と何の通信をするのかがわかりません。この問題を解決するのがシグナリングです。シグナリングは、2つのWebRTCエージェントが通信を開始できるように、通話をブートストラップするために使用されます。

シグナリングは、既存のプロトコルであるSDP（Session Description Protocol）を使用します。SDPはプレーンテキストのプロトコルです。各SDPメッセージは、キー／バリューペアで構成され、「メディアセクション」のリストを含んでいます。2つのWebRTCエージェントが交換するSDPには、以下のような詳細が含まれています。

* エージェントが到達可能なIPおよびポート (候補)
* エージェントが送信したいオーディオおよびビデオトラックの数
* 各エージェントがサポートするオーディオおよびビデオコーデック
* 接続時に使用される値 (uFrag/uPwd)
* セキュリティ確保時に使用される値 (証明書のフィンガープリント)

シグナリングは通常「アウトオブバンド」で行われることに注意してください。つまり、アプリケーションは通常、WebRTC自体を使用してシグナリングメッセージを交換することはありません。メッセージの送信に適した任意のアーキテクチャを使用して、接続しているピア間で SDP を中継することができます。また、多くのアプリケーションは、既存のインフラストラクチャ (REST エンドポイント、WebSocket 接続、または認証プロキシ) を使用して、適切なクライアント間で SDP を簡単に交換できるようにします。

### STUN/TURN による接続と NAT トラバーサル

これで、2 つの WebRTC Agent は、お互いに接続を試みるのに十分な詳細を知ることができました。WebRTC は ICE という別の確立された技術を使用します。

ICE（Interactive Connectivity Establishment）は、WebRTC よりも前のプロトコルです。ICEでは、2つのAgent間で接続を確立することができます。これらのAgentは、同じネットワーク上にある場合もあれば、地球の反対側にある場合もあります。ICEは、中央のサーバーを使わずに直接接続を確立するためのソリューションです。

ここでの本当の魔法は、「NATトラバーサル」と「STUN/TURNサーバー」です。この2つの概念があれば、別のサブネットにいるICEエージェントと通信することができます。これらのトピックについては、後ほど詳しく説明します。

ICE が接続に成功すると、WebRTC は暗号化トランスポートの確立に進みます。このトランスポートは、音声、ビデオ、データに使用されます。


### DTLS と SRTP によるトランスポート層のセキュリティ確保

ICE による双方向通信が可能になったところで、安全な通信を確立する必要があります。これには、WebRTC よりも古い 2 つのプロトコルを使用します。1つ目のプロトコルはDTLS（Datagram Transport Layer Security）で、これはUDP上のTLSに過ぎません。TLSは、HTTPSでの通信を保護するために使用される暗号化プロトコルです。2つ目のプロトコルはSRTP（Secure Real-time Transport Protocol）です。

まず、WebRTCはICEで確立された接続の上でDTLSハンドシェイクを行って接続します。HTTPS とは異なり、WebRTC は証明書に中央機関を使用しません。代わりに、WebRTC は、DTLS を通じて交換された証明書が、シグナリングによって共有されたフィンガープリントと一致することを表明します。このDTLS接続は、DataChannelメッセージに使用されます。

WebRTCは、RTPと呼ばれるオーディオ／ビデオ伝送用の別のプロトコルを使用します。RTP パケットのセキュリティには SRTP を使用します。SRTP セッションは、ネゴシエートされた DTLS セッションからキーを抽出して初期化します。後の章では、メディア伝送に独自のプロトコルが必要な理由について説明します。

これで完了です。これで、双方向の安全な通信が可能になりました。WebRTC エージェント間の接続が安定していれば、これだけで複雑な作業は必要ありません。残念ながら、現実の世界ではパケットロスや帯域幅の制限があり、次のセクションではそれらに対処する方法を説明します。

### RTP および SCTP によるピアとの通信

これで2つのWebRTC Agentが安全な双方向通信を行うことができました。それでは早速、通信を開始しましょう。ここでも、既存の 2 つのプロトコルを使用します。RTP（Real-time Transport Protocol）とSCTP（Stream Control Transmission Protocol）です。RTPでやり取りされるメディアの暗号化にはSRTPを、DTLSで暗号化されたDataChannelメッセージの送信にはSCTPを使用します。

RTPは最小限の機能しか備えていませんが、リアルタイムストリーミングを実現するために必要な機能を備えています。重要なのは、RTPが開発者に柔軟性を与えていることで、開発者はレイテンシー、ロス、輻輳を思い通りに処理することができます。この点については、「メディア」の章で詳しく説明します。

スタックの最後のプロトコルはSCTPです。SCTPでは、メッセージの配信オプションが多数用意されています。オプションで、信頼性のない、順番のない配信を選択することができますので、リアルタイムシステムに必要なレイテンシーを得ることができます。

## プロトコルの集合体であるWebRTC

WebRTCは多くの問題を解決します。最初は、過剰な技術とさえ思えるかもしれません。WebRTCの天才的なところは、実に謙虚なところです。WebRTCは、自分たちがすべてをうまく解決できるとは考えませんでした。その代わりに、多くの既存の単一目的の技術を採用し、それらを束ねました。

これにより、私たちは圧倒されることなく、各部分を個別に検討し、学ぶことができるのです。WebRTCエージェント」とは、実際には多くの異なるプロトコルのオーケストレーターに過ぎないことを視覚化するのに良い方法です。

![WebRTC Agent](../images/01-webrtc-agent.png "WebRTC Agent Diagram")

## WebRTC (API) はどのように動作するか

このセクションでは、JavaScript の API がプロトコルにどのように対応するかを示します。これは、WebRTC API の広範なデモを意味するものではなく、すべてがどのように結びついているかのメンタルモデルを作成するためのものです。
どちらにも慣れていない方でも問題ありません。このセクションは、より多くのことを学ぶために戻ってくる楽しみがあるかもしれません。

#### `new RTCPeerConnection`

`RTCPeerConnection` は、トップレベルの「WebRTCセッション」です。これには上述のすべてのプロトコルが含まれています。サブシステムはすべて割り当てられていますが、まだ何も起こりません。

#### `addTrack`

`addTrack` は新しい RTP ストリームを作成します。このストリームには、ランダムな同期ソース (SSRC) が生成されます。このストリームは、メディアセクション内の `createOffer` で生成されたセッション記述の中に入ります。 `addTrack` を呼び出すたびに、新しいSSRCとメディアセクションが作成されます。

SRTPセッションが確立されるとすぐに、これらのメディアパケットはSRTPで暗号化された後、ICE経由で送信され始めます。

#### `createDataChannel`

`createDataChannel` は、SCTPアソシエーションが存在しない場合に、新しいSCTPストリームを作成します。デフォルトでは、SCTPは有効ではなく、一方の側がデータチャネルを要求したときにのみ開始されます。

DTLSセッションが確立された直後に、SCTPアソシエーションはICEを経由してDTLSで暗号化されたパケットの送信を開始します。

#### `createOffer`

`createOffer` は、リモートピアと共有するローカルステートのSession Descriptionを生成します。

`createOffer` を呼び出しても、ローカルピアは何も変わりません。

#### `setLocalDescription`

`setLocalDescription` は要求されたすべての変更をコミットします。`addTrack`, `createDataChannel` などの呼び出しは、この呼び出しまではすべて一時的なものです。 `setLocalDescription` は `createOffer` で生成された値で呼び出されます。

通常、この呼び出しの後、リモートピアにオファーを送信し、リモートピアはそれを使って `setRemoteDescription` を呼び出します。

#### `setRemoteDescription`

`setRemoteDescription` は、リモート候補の状態をローカルエージェントに通知する方法です。これは、JavaScriptのAPIで「シグナリング」という行為を行う方法です。

双方で `setRemoteDescription` が呼び出されると、WebRTCエージェントはP2P通信を開始するのに十分な情報を得ることができます!

#### `addIceCandidate`

`addIceCandidate` を使うと、WebRTCエージェントはいつでも好きなときにリモートのICE候補を追加することができます。この API は ICE サブシステムに ICE Candidate を直接送信し、大規模な WebRTC 接続には他の影響を与えません。

#### `ontrack`

`ontrack` は、リモートピアからRTPパケットを受信したときに起動されるコールバックです。受信パケットは、`setRemoteDescription` に渡されたセッション記述で宣言されているはずです。

WebRTC は SSRC を使用して、関連する `MediaStream` と `MediaStreamTrack` を検索し、これらの詳細が入力された状態でこのコールバックを起動します。

#### `oniceconnectionstatechange`

`oniceconnectionstatechange` は、ICEエージェントの状態を反映して起動されるコールバックです。ネットワークに接続されたときや、切断されたときに、このように通知されます。

#### `onstatechange`

`onstatechange` は、ICEエージェントとDTLSエージェントの状態を組み合わせたものです。これを見ることで、ICEとDTLSの両方が正常に完了したときに通知を受けることができます。
